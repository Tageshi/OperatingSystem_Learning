# 1.操作系统接口

## 1.1 操作系统在计算机中的结构

（自顶向下）：应用→OS→系统硬件。应用自接口向内存工作。

## 1.2 接口概述

- 上层应用经过接口流向内核，用于连接两个东西、完成信号转化、屏蔽细节。操作系统接口一般是命令，接收用户发出的信号，并转换成用户想要的信息最终让其流向用户。
- 用户通过命令行、图形按钮、应用程序等使用计算机。（这三种方式称为用户和操作系统之间的接口）
  - 命令行对应一段可执行程序。shell通过编写一段命令行程序不断循环等待用户命令行的输入。输入命令行后，shell执行该命令行对应的程序，该程序最终输出用户可见的结果。
  - I/O设备请求输入时产生中断（如鼠标点击图标），放入系统内部的消息队列中，应用程序编写getMessage()方法循环逐一调用内核中的系统消息，根据不同的消息选择调用相应的方法（这个方法就是实现鼠标点击事件的方法）。
- 用户通过应用程序使用计算机，**用户程序与操作系统之间的接口就是各种接口函数**，由系统提供，故称为**系统调用**（System-call）。
  - 任务管理类系统调用（接口）
    - fork：创建一个进程
    - execl：运行一个可执行程序
    - pthread_create：创建一个线程
  - 文件系统类系统调用（接口）
    - open：打开一个文件或目录
    - EACCES：返回值，表示没有权限
    - mode_t st_mode：文件头结构：文件属性

# 2.系统调用的实现

## 2.1 系统调用的直观实现

- 例：用户程序进行系统调用（即调用位于内核的接口函数），如输出一个字符串，则接口函数将在内存中找到指定字符串随后输出。)

  事实上，这种直接读取内存的方法是不可行的。

  ```c++
  //用户程序（用户段）
  main(){
      whoami(); //系统调用
  }
  //内核层函数，即操作系统部分（内核段）
  whoami(){
      printf(100,3);
  }
  //内存100保存了长度为3的字符串“fzj”。
  //最后系统调用输出“fzj”
  ```

## 2.2 系统调用的三个问题

- 问题：为什么不直接在main函数中执行读取内存操作“printf(100,3)”？
  - 因为内存中包含了诸如root用户密码等安全信息，如果用户系统可以随意进行系统调用，那么这些信息将面临风险。故不可以随意在内存中jmp或mov。
- 问题：为什么不能进入内核？
  - 计算机对内存的使用以“段”为单位，用户态对应用户段（内存），内核态对应内核段（内存）。由于用户态的特权级为3，内核态的特权级为0，所以用户态无法访问内核段。（用GDT中的DPL和CS中的CPL检查特权等级，每次运行用户程序时CPL置3，DPL置1，CPL≠DPL时，不允许进入内核，无法启动shell）
- 问题：主动进入内核的方法
  - 通过中断指令int进入内核。int指令使CS中的CPL改成0，使之与DPL相等，从而进入内核。

## 2.3 系统调用的核心

- 用户程序中包含一段int指令代码（whoami()方法），即“int 0x80”。
- 操作系统写中断处理，获取想调程序的编号
- 操作系统根据编号执行相应代码

```c
main(){
    eax=72;
    int 0x80;
}
_system_call:
	call sys_whoami();  //通过 sys_call_table + eax*4 查表找到whoami方法体并执行
sys_whoami(){
    printk(100,3);   //此时使用“printk”是因为内核中不支持printf，printf常用在用户态
}

//内存中100:fzj
```



# 3.操作系统历史

## 3.1 批处理系统

- 通过监控程序来管理，所有作业在输入磁带中排队，在监控程序的监管下按顺序完成，完成后流入输出磁带。

## 3.2 多道程序设计

- 多个作业同时出现，需要**切换和调度**。
- 既有I/O任务，又有计算任务。

## 3.3 分时系统

- 需要一台计算机启动多个作业，**可以接入多个用户**。
- 定期快速切换，防止某个用户长期占用处理器。
- 核心依然是任务的切换。

总结：多进程结构是操作系统的基本图谱。操作系统主要包含进程管理和内存管理。
# 1.操作系统接口

## 1.1 操作系统在计算机中的结构

（自顶向下）：应用→OS→系统硬件。应用自接口向内存工作。

## 1.2 接口概述

- 上层应用经过接口流向内核，用于连接两个东西、完成信号转化、屏蔽细节。操作系统接口一般是命令，接收用户发出的信号，并转换成用户想要的信息最终让其流向用户。
- 用户通过命令行、图形按钮、应用程序等使用计算机。（这三种方式称为用户和操作系统之间的接口）
  - 命令行对应一段可执行程序。shell通过编写一段命令行程序不断循环等待用户命令行的输入。输入命令行后，shell执行该命令行对应的程序，该程序最终输出用户可见的结果。
  - I/O设备请求输入时产生中断（如鼠标点击图标），放入系统内部的消息队列中，应用程序编写getMessage()方法循环逐一调用内核中的系统消息，根据不同的消息选择调用相应的方法（这个方法就是实现鼠标点击事件的方法）。
- 用户通过应用程序使用计算机，**用户程序与操作系统之间的接口就是各种接口函数**，由系统提供，故称为**系统调用**（System-call）。
  - 任务管理类系统调用（接口）
    - fork：创建一个进程
    - execl：运行一个可执行程序
    - pthread_create：创建一个线程
  - 文件系统类系统调用（接口）
    - open：打开一个文件或目录
    - EACCES：返回值，表示没有权限
    - mode_t st_mode：文件头结构：文件属性

# 2.系统调用的实现

## 2.1 系统调用的直观实现

- 例：用户程序进行系统调用（即调用位于内核的接口函数），如输出一个字符串，则接口函数将在内存中找到指定字符串随后输出。)

  ```c++
  //用户程序（用户段）
  main(){
      whoami(); //系统调用
  }
  //内核层函数，即操作系统部分（内核段）
  whoami(){
      printf(100,3);
  }
  //内存100保存了长度为3的字符串“fzj”。
  //最后系统调用输出“fzj”
  ```

- 问题：为什么不直接在main函数中执行读取内存操作“printf(100,3)”？
  - 因为内存中包含了诸如root用户密码等安全信息，如果用户系统可以随意进行系统调用，那么这些信息将面临风险。故不可以随意在内存中jmp或mov。

- 计算机对内存的使用以“段”为单位，用户态对应用户段（内存），内核态对应内核段（内存）。
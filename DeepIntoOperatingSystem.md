# 1. 操作系统接口

## 1.1 操作系统在计算机中的结构

（自顶向下）：应用→OS→系统硬件。应用自接口向内存工作。

## 1.2 接口概述

- 上层应用经过接口流向内核，用于连接两个东西、完成信号转化、屏蔽细节。操作系统接口一般是命令，接收用户发出的信号，并转换成用户想要的信息最终让其流向用户。
- 用户通过命令行、图形按钮、应用程序等使用计算机。（这三种方式称为用户和操作系统之间的接口）
  - 命令行对应一段可执行程序。shell通过编写一段命令行程序不断循环等待用户命令行的输入。输入命令行后，shell执行该命令行对应的程序，该程序最终输出用户可见的结果。
  - I/O设备请求输入时产生中断（如鼠标点击图标），放入系统内部的消息队列中，应用程序编写getMessage()方法循环逐一调用内核中的系统消息，根据不同的消息选择调用相应的方法（这个方法就是实现鼠标点击事件的方法）。
- 用户通过应用程序使用计算机，**用户程序与操作系统之间的接口就是各种接口函数**，由系统提供，故称为**系统调用**（System-call）。
  - 任务管理类系统调用（接口）
    - fork：创建一个进程
    - execl：运行一个可执行程序
    - pthread_create：创建一个线程
  - 文件系统类系统调用（接口）
    - open：打开一个文件或目录
    - EACCES：返回值，表示没有权限
    - mode_t st_mode：文件头结构：文件属性

# 2. 系统调用的实现

## 2.1 系统调用的直观实现

- 例：用户程序进行系统调用（即调用位于内核的接口函数），如输出一个字符串，则接口函数将在内存中找到指定字符串随后输出。)

  事实上，这种直接读取内存的方法是不可行的。

  ```c++
  //用户程序（用户段）
  main(){
      whoami(); //系统调用
  }
  //内核层函数，即操作系统部分（内核段）
  whoami(){
      printf(100,3);
  }
  //内存100保存了长度为3的字符串“fzj”。
  //最后系统调用输出“fzj”
  ```

## 2.2 系统调用的三个问题

- 问题：为什么不直接在main函数中执行读取内存操作“printf(100,3)”？
  - 因为内存中包含了诸如root用户密码等安全信息，如果用户系统可以随意进行系统调用，那么这些信息将面临风险。故不可以随意在内存中jmp或mov。
- 问题：为什么不能进入内核？
  - 计算机对内存的使用以“段”为单位，用户态对应用户段（内存），内核态对应内核段（内存）。由于用户态的特权级为3，内核态的特权级为0，所以用户态无法访问内核段。（用GDT中的DPL和CS中的CPL检查特权等级，每次运行用户程序时CPL置3，DPL置1，CPL≠DPL时，不允许进入内核，无法启动shell）
- 问题：主动进入内核的方法
  - 通过中断指令int进入内核。int指令使CS中的CPL改成0，使之与DPL相等，从而进入内核。

## 2.3 系统调用的核心

- 用户程序中包含一段int指令代码（whoami()方法），即“int 0x80”。
- 操作系统写中断处理，获取想调程序的编号
- 操作系统根据编号执行相应代码

```c
main(){
    eax=72;
    int 0x80;
}
_system_call:
	call sys_whoami();  //通过 sys_call_table + eax*4 查表找到whoami方法体并执行
sys_whoami(){
    printk(100,3);   //此时使用“printk”是因为内核中不支持printf，printf常用在用户态
}

//内存中100:fzj
```



# 3. 操作系统历史

## 3.1 批处理系统

- 通过监控程序来管理，所有作业在输入磁带中排队，在监控程序的监管下按顺序完成，完成后流入输出磁带。

## 3.2 多道程序设计

- 多个作业同时出现，需要**切换和调度**。
- 既有I/O任务，又有计算任务。

## 3.3 分时系统

- 需要一台计算机启动多个作业，**可以接入多个用户**。
- 定期快速切换，防止某个用户长期占用处理器。
- 核心依然是任务的切换。

总结：多进程结构是操作系统的基本图谱。操作系统主要包含进程管理和内存管理。



# 4. CPU管理

- 设置好PC初值后，CPU自动不断取指和执行指令。

  - 但如果是单道程序设计，出现I/O指令时CPU只能等待I/O设备读写完成，因为I/O设备读写速度极慢，所以CPU利用率会大幅降低
  - 为提高CPU利用率，在I/O接口工作时，CPU可以产生中断而去执行别的工作，待I/O执行完毕发生中断时，CPU再切回继续执行后续指令，这就用到了多道程序设计的思想。
  - 因此，PC在设计时必须考虑到CPU产生中断需要执行另一程序时PC的值应该如何修改。修改PC的工作由操作系统完成。

  <img src="C:\Users\23215\Desktop\DeepIntoOperatingSystem.assets\微信截图_20221010110556.png" alt="微信截图_20221010110556" style="zoom: 67%;" />

## 4.1 多道程序设计

- CPU**并发**执行多道程序，提高利用率。

<img src="C:\Users\23215\Desktop\DeepIntoOperatingSystem.assets\微信截图_20221010110637.png" alt="微信截图_20221010110637" style="zoom:67%;" />
$$
CPU利用率=（10+10+5+5+10）/45=89\%
$$

- PC在切换到另一程序的入口地址后，CPU工作时可能涉及到对上一程序（现在正在执行I/O指令的程序）某些信息的修改，导致切回到该程序继续工作时，这些信息已经被修改，产生脏读问题。因此，CPU需要一个在产生中断时保护中断现场信息的存储结构，也就是**PCB**（程序控制块，用来记录进程信息的数据结构）。  

## 4.2 多进程

- 启动计算机后，main中的fork()函数启动第一个进程shell（Windows桌面），用户通过图形界面操作计算机取启动其他进程（shell返回其他进程）。

- 进程有执行（执行队列）、等待执行（就绪队列）、等待某事件发生后再等待执行（磁盘等待队列）三种状态。

  - 进程可以分为新建态、**就绪态**、**运行态**、**阻塞态**、终止态等状态。

  <img src="C:\Users\23215\Desktop\DeepIntoOperatingSystem.assets\微信截图_20221010110010.png" alt="微信截图_20221010110010" style="zoom:50%;" />

  - 进程在哪个队列（是什么状态）由PCB标识并告知CPU。
  
- 多进程通过自身的PCB改变状态进入不同队列从而**交替**执行。

  - 进程A启动磁盘读写（等待I/O设备）

    ```c++
    pCur.state='W'; //PCB将自己的状态变为阻塞态，进程进入磁盘等待队列DiskWaitQueue
    schedule(); //执行进程的切换
    ```

    ```c++
    schedule(){
        //切换进程，从当前的PCB换到下一个合适的PCB
    }
    ```
  
- 进程调度主要分为FIFO（先进先出）、优先级调度两种。     

- PCB保存中断信息，该进程再次被CPU执行时PCB将信息与CPU交换。

- 通过映射表，多个进程访问同一地址代码时可以避免撞车。（如PA访问m[100]实际访问800，如PB访问m[100]实际访问600）